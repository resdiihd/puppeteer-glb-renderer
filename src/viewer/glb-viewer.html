<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Viewer - Puppeteer Renderer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 100;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>Loading GLB Viewer...</div>
        </div>
        <div id="info">
            <div id="model-info">No model loaded</div>
            <div id="camera-info">Camera: Perspective</div>
            <div id="render-info">Renderer: WebGL</div>
        </div>
    </div>

    <!-- Three.js and GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/controls/OrbitControls.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/environments/RoomEnvironment.min.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let model = null;
        let mixer = null;
        let clock = new THREE.Clock();
        let currentLighting = 'studio';
        let animations = [];
        let currentView = 'perspective';
        let modelBoundingBox = null;
        
        // Global state for Puppeteer
        window.modelLoaded = false;
        window.THREE = THREE;
        window.GLTFLoader = THREE.GLTFLoader;

        // Initialize the 3D scene
        async function init() {
            console.log('üé® Initializing GLB Viewer...');
            
            const container = document.getElementById('container');
            const loading = document.getElementById('loading');
            
            try {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x222222);
                
                // Camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(5, 3, 5);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true // Important for screenshots
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                
                container.appendChild(renderer.domElement);
                
                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = true;
                
                // Setup default lighting
                setupLighting('studio');
                
                // Hide loading
                loading.style.display = 'none';
                
                console.log('‚úÖ GLB Viewer initialized');
                
                // Start render loop
                animate();
                
            } catch (error) {
                console.error('‚ùå Failed to initialize viewer:', error);
                loading.innerHTML = '<div style="color: red;">Failed to initialize viewer</div>';
            }
        }

        function setupLighting(type = 'studio') {
            // Clear existing lights
            const existingLights = scene.children.filter(child => child.isLight);
            existingLights.forEach(light => scene.remove(light));
            
            switch (type) {
                case 'studio':
                    // Studio lighting setup
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                    scene.add(ambientLight);
                    
                    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
                    mainLight.position.set(5, 10, 5);
                    mainLight.castShadow = true;
                    mainLight.shadow.mapSize.width = 2048;
                    mainLight.shadow.mapSize.height = 2048;
                    scene.add(mainLight);
                    
                    const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
                    fillLight.position.set(-5, 5, -5);
                    scene.add(fillLight);
                    
                    const rimLight = new THREE.DirectionalLight(0x88ccff, 0.4);
                    rimLight.position.set(0, 5, -10);
                    scene.add(rimLight);
                    break;
                    
                case 'outdoor':
                    // Outdoor/daylight setup
                    const skyLight = new THREE.HemisphereLight(0x87ceeb, 0x8b4513, 0.8);
                    scene.add(skyLight);
                    
                    const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
                    sunLight.position.set(10, 20, 10);
                    sunLight.castShadow = true;
                    scene.add(sunLight);
                    break;
                    
                case 'dramatic':
                    // Dramatic/moody lighting
                    const dramaticAmbient = new THREE.AmbientLight(0x444444, 0.2);
                    scene.add(dramaticAmbient);
                    
                    const spotLight = new THREE.SpotLight(0xffffff, 2.0);
                    spotLight.position.set(0, 15, 0);
                    spotLight.angle = Math.PI / 4;
                    spotLight.penumbra = 0.3;
                    spotLight.castShadow = true;
                    scene.add(spotLight);
                    
                    const coloredLight = new THREE.PointLight(0xff4444, 0.8);
                    coloredLight.position.set(-10, 5, 5);
                    scene.add(coloredLight);
                    break;
            }
            
            currentLighting = type;
            console.log(`üí° Lighting setup: ${type}`);
        }

        // Load GLB model - called by Puppeteer
        window.loadGLBModel = async function(glbPath, options = {}) {
            return new Promise((resolve, reject) => {
                console.log(`üìÅ Loading GLB: ${glbPath}`);
                
                const loader = new THREE.GLTFLoader();
                
                loader.load(
                    glbPath,
                    (gltf) => {
                        try {
                            // Remove existing model
                            if (model) {
                                scene.remove(model);
                            }
                            
                            model = gltf.scene;
                            scene.add(model);
                            
                            // Calculate bounding box
                            const box = new THREE.Box3().setFromObject(model);
                            modelBoundingBox = box;
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            
                            // Center the model
                            model.position.sub(center);
                            
                            // Scale model to fit in view
                            const maxDimension = Math.max(size.x, size.y, size.z);
                            if (maxDimension > 10) {
                                const scale = 8 / maxDimension;
                                model.scale.setScalar(scale);
                            }
                            
                            // Setup animations
                            if (gltf.animations && gltf.animations.length > 0) {
                                mixer = new THREE.AnimationMixer(model);
                                animations = gltf.animations.map(clip => {
                                    const action = mixer.clipAction(clip);
                                    return { name: clip.name, action };
                                });
                                
                                // Start first animation if available
                                if (animations.length > 0) {
                                    animations[0].action.play();
                                }
                                
                                console.log(`üé≠ Found ${animations.length} animations`);
                            }
                            
                            // Enable shadows on model
                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            // Adjust camera position
                            const distance = maxDimension * 2;
                            camera.position.set(distance, distance * 0.6, distance);
                            camera.lookAt(0, 0, 0);
                            
                            // Update controls
                            controls.target.set(0, 0, 0);
                            controls.update();
                            
                            window.modelLoaded = true;
                            updateInfo();
                            
                            console.log('‚úÖ GLB model loaded successfully');
                            resolve(true);
                            
                        } catch (error) {
                            console.error('‚ùå Error processing loaded GLB:', error);
                            reject(error);
                        }
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        console.log(`üìä Loading progress: ${percent}%`);
                    },
                    (error) => {
                        console.error('‚ùå Error loading GLB:', error);
                        reject(error);
                    }
                );
            });
        };

        // Apply render settings - called by Puppeteer
        window.applyRenderSettings = function(options) {
            console.log('‚öôÔ∏è Applying render settings:', options);
            
            // Background
            if (options.background) {
                if (options.transparent) {
                    scene.background = null;
                    renderer.setClearColor(0x000000, 0);
                } else {
                    scene.background = new THREE.Color(options.background);
                }
            }
            
            // Lighting
            if (options.lighting) {
                setupLighting(options.lighting);
            }
            
            // Shadows
            renderer.shadowMap.enabled = options.shadows !== false;
            
            // Quality settings based on preset
            if (options.preset) {
                switch (options.preset) {
                    case 'ultra':
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio * 2, 3));
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        break;
                    case 'high':
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        renderer.shadowMap.type = THREE.PCFShadowMap;
                        break;
                    case 'medium':
                        renderer.setPixelRatio(1);
                        renderer.shadowMap.type = THREE.BasicShadowMap;
                        break;
                    case 'low':
                        renderer.setPixelRatio(0.5);
                        renderer.shadowMap.enabled = false;
                        break;
                }
            }
            
            console.log('‚úÖ Render settings applied');
        };

        // Set camera view - called by Puppeteer
        window.setCameraView = function(view) {
            if (!modelBoundingBox) return;
            
            const size = modelBoundingBox.getSize(new THREE.Vector3());
            const maxDimension = Math.max(size.x, size.y, size.z);
            const distance = maxDimension * 2.5;
            
            switch (view) {
                case 'front':
                    camera.position.set(0, 0, distance);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'back':
                    camera.position.set(0, 0, -distance);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'side':
                case 'left':
                    camera.position.set(-distance, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'right':
                    camera.position.set(distance, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'top':
                    camera.position.set(0, distance, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'bottom':
                    camera.position.set(0, -distance, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'perspective':
                default:
                    camera.position.set(distance * 0.8, distance * 0.6, distance * 0.8);
                    camera.lookAt(0, 0, 0);
                    break;
            }
            
            controls.update();
            currentView = view;
            updateInfo();
            
            console.log(`üì∑ Camera view set to: ${view}`);
        };

        // Rotate camera for turntable animation - called by Puppeteer
        window.rotateCameraToAngle = function(angle) {
            if (!modelBoundingBox) return;
            
            const size = modelBoundingBox.getSize(new THREE.Vector3());
            const maxDimension = Math.max(size.x, size.y, size.z);
            const distance = maxDimension * 2;
            
            const radians = (angle * Math.PI) / 180;
            const x = Math.sin(radians) * distance;
            const z = Math.cos(radians) * distance;
            const y = distance * 0.3; // Slight elevation
            
            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);
            controls.update();
        };

        function updateInfo() {
            const info = document.getElementById('info');
            const modelInfo = document.getElementById('model-info');
            const cameraInfo = document.getElementById('camera-info');
            const renderInfo = document.getElementById('render-info');
            
            if (model) {
                modelInfo.textContent = `Model: Loaded (${model.children.length} objects)`;
            }
            
            cameraInfo.textContent = `Camera: ${currentView} (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`;
            renderInfo.textContent = `Renderer: WebGL | Lighting: ${currentLighting}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update animations
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            // Update controls
            controls.update();
            
            // Render
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Show info on key press
        document.addEventListener('keydown', (event) => {
            if (event.key === 'i' || event.key === 'I') {
                const info = document.getElementById('info');
                info.style.display = info.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Initialize when page loads
        window.addEventListener('load', init);
        
        console.log('üé® GLB Viewer script loaded');
    </script>
</body>
</html>